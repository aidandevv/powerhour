---
phase: 01-security-foundation-agent-tools
plan: "02"
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/agent/tools/spending-summary.ts
  - lib/agent/tools/account-balances.ts
  - lib/agent/tools/transaction-search.ts
  - lib/agent/tools/trend-comparison.ts
  - lib/agent/tools/recurring-expenses.ts

autonomous: true

must_haves:
  truths:
    - "Calling getSpendingSummary({ from: '2025-01-01', to: '2025-01-31' }) returns { summary: [...], from, to, totalSpend } with no plaidAccessToken or encrypted blob fields"
    - "Calling getAccountBalances() returns { accounts: [...], totalAssets, totalLiabilities, netWorth } — account objects contain no plaid_access_token"
    - "Calling searchTransactions({ query: 'Amazon', limit: 5 }) returns an array of transaction objects with id, date, name, amount, category, accountName"
    - "Calling compareTrends({ metric: 'spending', period1From: '...', period1To: '...', period2From: '...', period2To: '...' }) returns comparison data for both periods"
    - "Calling getRecurringExpenses() returns an array of recurring items with name, amount, frequency — no sensitive institution data"
    - "All five tool functions are pure async TypeScript functions — no AI SDK imports, no tool() wrapper, no LangChain"
    - "All five functions have typed input interfaces and typed return interfaces (no 'any' types)"
  artifacts:
    - path: "lib/agent/tools/spending-summary.ts"
      provides: "TOOL-01: getSpendingSummary() — spending by category for a date range"
      exports: ["SpendingSummaryParams", "SpendingSummaryResult", "getSpendingSummary"]
    - path: "lib/agent/tools/account-balances.ts"
      provides: "TOOL-02: getAccountBalances() — all account balances with net worth"
      exports: ["AccountBalancesResult", "getAccountBalances"]
    - path: "lib/agent/tools/transaction-search.ts"
      provides: "TOOL-03: searchTransactions() — keyword/merchant search with date range"
      exports: ["transactionSearchSchema", "TransactionSearchParams", "searchTransactions"]
    - path: "lib/agent/tools/trend-comparison.ts"
      provides: "TOOL-04: compareTrends() — spending comparison across two time periods"
      exports: ["TrendComparisonParams", "TrendComparisonResult", "compareTrends"]
    - path: "lib/agent/tools/recurring-expenses.ts"
      provides: "TOOL-05: getRecurringExpenses() — active recurring items listing"
      exports: ["RecurringExpensesResult", "getRecurringExpenses"]
  key_links:
    - from: "lib/agent/tools/account-balances.ts"
      to: "lib/db/views.ts"
      via: "imports agentAccountsView, queries it via db.select().from(agentAccountsView)"
      pattern: "from.*agentAccountsView"
    - from: "lib/agent/tools/spending-summary.ts"
      to: "lib/db/schema.ts"
      via: "imports transactions, accounts tables — joins accounts but never institutions base table"
      pattern: "from.*transactions.*accounts"
    - from: "lib/agent/tools/transaction-search.ts"
      to: "lib/db/schema.ts"
      via: "imports transactions, accounts — never selects from institutions"
      pattern: "from.*transactions"
    - from: "lib/agent/tools/trend-comparison.ts"
      to: "lib/db/schema.ts"
      via: "imports transactions for two-period aggregate comparison"
      pattern: "from.*transactions"
    - from: "lib/agent/tools/recurring-expenses.ts"
      to: "lib/db/schema.ts"
      via: "imports recurringItems, accounts — joins accounts to get account name, never institutions"
      pattern: "from.*recurringItems"
---

<objective>
Implement all five agent tool functions as pure async TypeScript functions querying Drizzle. These are the data access layer for the AI agent — plain functions the AI SDK's tool() will wrap in Phase 2.

Purpose: The agent can only answer financial questions accurately if these functions return correct, typed, safe data from the real database. Building and testing them in isolation here means Phase 2 can focus entirely on the AI loop.

Output: Five files in lib/agent/tools/ — one per tool — all read-only, all typed, all querying safe views or projected columns (never the institutions base table).
</objective>

<execution_context>
@/Users/aidan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aidan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation-agent-tools/01-RESEARCH.md
@lib/db/schema.ts
@lib/db/views.ts
@lib/db/index.ts
@.planning/phases/01-security-foundation-agent-tools/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TOOL-01 getSpendingSummary + TOOL-02 getAccountBalances</name>
  <files>
    lib/agent/tools/spending-summary.ts
    lib/agent/tools/account-balances.ts
  </files>
  <action>
Create the `lib/agent/tools/` directory and two files.

**File 1: `lib/agent/tools/spending-summary.ts`** — TOOL-01

SEC-02: Queries only `transactions` and `accounts` tables (SELECT only — no INSERT/UPDATE/DELETE possible with Drizzle .select()).
SEC-03: Does NOT join or select from the `institutions` table — no encrypted fields possible.

```typescript
/**
 * TOOL-01: Spending summary by category for a date range
 *
 * SEC-02: Read-only — uses Drizzle .select() which generates SELECT SQL only
 * SEC-03: Does not touch institutions table — no plaid_access_token exposure
 * SEC-06: Input validated by TypeScript types (AI SDK will add Zod in Phase 2)
 */
import { db } from "@/lib/db";
import { transactions, accounts } from "@/lib/db/schema";
import { and, gte, lte, gt, sql, eq } from "drizzle-orm";

export interface SpendingSummaryParams {
  from: string;   // ISO date "YYYY-MM-DD"
  to: string;     // ISO date "YYYY-MM-DD"
  category?: string; // Optional filter to a specific category
}

export interface SpendingSummaryRow {
  category: string;
  amount: number;
  count: number;
}

export interface SpendingSummaryResult {
  summary: SpendingSummaryRow[];
  from: string;
  to: string;
  totalSpend: number;
}

export async function getSpendingSummary(
  params: SpendingSummaryParams
): Promise<SpendingSummaryResult> {
  const { from, to, category } = params;

  const conditions = [
    gte(transactions.date, from),
    lte(transactions.date, to),
    // Only include debits (positive amount = money out in Plaid convention)
    gt(transactions.amount, "0"),
    // Exclude pending transactions for accuracy
    eq(transactions.pending, false),
  ];

  if (category) {
    conditions.push(eq(transactions.category, category));
  }

  const rows = await db
    .select({
      category: transactions.category,
      total: sql<string>`sum(${transactions.amount})`,
      count: sql<number>`count(*)::int`,
    })
    .from(transactions)
    .innerJoin(accounts, eq(transactions.accountId, accounts.id))
    .where(and(...conditions))
    .groupBy(transactions.category)
    .orderBy(sql`sum(${transactions.amount}) desc`);

  const summary: SpendingSummaryRow[] = rows.map((r) => ({
    category: r.category ?? "Uncategorized",
    amount: parseFloat(r.total ?? "0"),
    count: r.count,
  }));

  return {
    summary,
    from,
    to,
    totalSpend: summary.reduce((sum, r) => sum + r.amount, 0),
  };
}
```

**File 2: `lib/agent/tools/account-balances.ts`** — TOOL-02

SEC-03: Queries `agentAccountsView` (from lib/db/views.ts) — the view excludes plaid_access_token, sync_cursor, error_code.
IMPORTANT: import from `@/lib/db/views` not from base schema tables.

```typescript
/**
 * TOOL-02: Account balances across all institutions
 *
 * SEC-02: Read-only — queries agentAccountsView (a PostgreSQL VIEW, which is
 *         inherently read-only — no INSERT/UPDATE/DELETE possible against a view
 *         without an INSTEAD OF trigger, which we have not defined)
 * SEC-03: agentAccountsView excludes plaid_access_token, sync_cursor, error_code
 *         from the institutions table. Safe to return in agent results.
 */
import { db } from "@/lib/db";
import { agentAccountsView } from "@/lib/db/views";
import { eq } from "drizzle-orm";

export interface AccountRow {
  id: string;
  name: string;
  type: string;
  subtype: string | null;
  currentBalance: number | null;
  availableBalance: number | null;
  creditLimit: number | null;
  currencyCode: string;
  institutionName: string;
}

export interface AccountBalancesResult {
  accounts: AccountRow[];
  totalAssets: number;
  totalLiabilities: number;
  netWorth: number;
}

export async function getAccountBalances(): Promise<AccountBalancesResult> {
  const rows = await db
    .select()
    .from(agentAccountsView)
    .where(eq(agentAccountsView.isActive, true));

  let totalAssets = 0;
  let totalLiabilities = 0;

  const accounts: AccountRow[] = rows.map((r) => {
    const balance = parseFloat(String(r.currentBalance ?? "0"));
    // Credit and loan accounts: balance is what's owed (liability)
    if (r.type === "credit" || r.type === "loan") {
      totalLiabilities += Math.abs(balance);
    } else {
      // Depository, investment, etc: balance is an asset
      totalAssets += balance;
    }

    return {
      id: r.id!,
      name: r.name!,
      type: r.type!,
      subtype: r.subtype ?? null,
      currentBalance: r.currentBalance !== null
        ? parseFloat(String(r.currentBalance))
        : null,
      availableBalance: r.availableBalance !== null
        ? parseFloat(String(r.availableBalance))
        : null,
      creditLimit: r.creditLimit !== null
        ? parseFloat(String(r.creditLimit))
        : null,
      currencyCode: r.currencyCode ?? "USD",
      institutionName: r.institutionName!,
    };
  });

  return {
    accounts,
    totalAssets,
    totalLiabilities,
    netWorth: totalAssets - totalLiabilities,
  };
}
```
  </action>
  <verify>
1. TypeScript compiles both files:
```bash
npx tsc --noEmit 2>&1 | grep -E "agent/tools/(spending|account)"
```
Expect no output (no errors).

2. Verify neither file imports from `institutions` table directly:
```bash
grep -n "institutions" lib/agent/tools/spending-summary.ts lib/agent/tools/account-balances.ts
```
Expect: `account-balances.ts` has no mention of `institutions`. `spending-summary.ts` has no mention.

3. Verify account-balances.ts imports from views, not base schema:
```bash
grep "import.*views" lib/agent/tools/account-balances.ts
```
Expect: `import { agentAccountsView } from "@/lib/db/views"`

4. Smoke test against real database (requires DATABASE_URL in env):
```bash
npx ts-node --project tsconfig.json -e "
const { getSpendingSummary } = require('./lib/agent/tools/spending-summary');
const { getAccountBalances } = require('./lib/agent/tools/account-balances');
async function test() {
  const spending = await getSpendingSummary({ from: '2025-01-01', to: '2025-12-31' });
  console.log('TOOL-01 result:', JSON.stringify(spending, null, 2));
  const keys = Object.keys(spending);
  if (!keys.includes('summary') || !keys.includes('totalSpend')) throw new Error('Missing fields');

  const balances = await getAccountBalances();
  console.log('TOOL-02 result:', JSON.stringify(balances, null, 2));
  if (!balances.accounts || typeof balances.netWorth !== 'number') throw new Error('Missing fields');

  // SEC-03: verify no sensitive fields in results
  const resultStr = JSON.stringify({ spending, balances });
  if (resultStr.includes('plaidAccessToken') || resultStr.includes('syncCursor')) {
    throw new Error('SECURITY FAIL: sensitive field in result');
  }
  console.log('PASS: TOOL-01 and TOOL-02 returned safe data');
}
test().catch(e => { console.error('FAIL:', e); process.exit(1); });
"
```
  </verify>
  <done>
- `lib/agent/tools/spending-summary.ts` exports `SpendingSummaryParams`, `SpendingSummaryResult`, `getSpendingSummary`
- `lib/agent/tools/account-balances.ts` exports `AccountBalancesResult`, `getAccountBalances`
- Neither file imports from `institutions` base table
- `account-balances.ts` imports from `@/lib/db/views` (agentAccountsView)
- TypeScript compiles without errors
- Smoke test returns structured data with no `plaidAccessToken` or `syncCursor` fields
  </done>
</task>

<task type="auto">
  <name>Task 2: TOOL-03 searchTransactions + TOOL-04 compareTrends + TOOL-05 getRecurringExpenses</name>
  <files>
    lib/agent/tools/transaction-search.ts
    lib/agent/tools/trend-comparison.ts
    lib/agent/tools/recurring-expenses.ts
  </files>
  <action>
Create three more tool files. None of these need the agent views — they query `transactions`, `accounts`, and `recurringItems` which contain no sensitive data.

**File 1: `lib/agent/tools/transaction-search.ts`** — TOOL-03

SEC-06: Exports a Zod schema `transactionSearchSchema` — this is both the runtime validation for Phase 2's AI SDK `inputSchema` AND the TypeScript type source. Use it to validate params before querying.

```typescript
/**
 * TOOL-03: Transaction search by merchant name, keyword, or date range
 *
 * SEC-02: Drizzle .select() — generates SELECT only
 * SEC-03: Joins only accounts, never institutions table
 * SEC-06: transactionSearchSchema validates all inputs (Zod) before DB query
 *
 * NOTE: transactionSearchSchema is also used as inputSchema in the Phase 2
 * AI SDK tool() wrapper. Export it explicitly for reuse.
 */
import { db } from "@/lib/db";
import { transactions, accounts } from "@/lib/db/schema";
import { and, gte, lte, ilike, desc, eq, or } from "drizzle-orm";
import { z } from "zod";

export const transactionSearchSchema = z.object({
  query: z.string().min(1).max(100).describe("Merchant name or keyword to search"),
  from: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD")
    .optional()
    .describe("Start date in YYYY-MM-DD format"),
  to: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD")
    .optional()
    .describe("End date in YYYY-MM-DD format"),
  limit: z.number().int().min(1).max(50).default(20),
});

export type TransactionSearchParams = z.infer<typeof transactionSearchSchema>;

export interface TransactionSearchRow {
  id: string;
  date: string;
  name: string;
  merchantName: string | null;
  amount: number;
  category: string | null;
  accountName: string;
}

export async function searchTransactions(
  params: TransactionSearchParams
): Promise<TransactionSearchRow[]> {
  // Validate params with Zod (SEC-06: sanitize before query)
  const validated = transactionSearchSchema.parse(params);
  const { query, from, to, limit } = validated;

  const conditions = [
    or(
      ilike(transactions.name, `%${query}%`),
      ilike(transactions.merchantName, `%${query}%`)
    )!,
  ];

  if (from) conditions.push(gte(transactions.date, from));
  if (to) conditions.push(lte(transactions.date, to));

  const rows = await db
    .select({
      id: transactions.id,
      date: transactions.date,
      name: transactions.name,
      merchantName: transactions.merchantName,
      amount: transactions.amount,
      category: transactions.category,
      accountName: accounts.name,
    })
    .from(transactions)
    .innerJoin(accounts, eq(transactions.accountId, accounts.id))
    .where(and(...conditions))
    .orderBy(desc(transactions.date))
    .limit(limit);

  return rows.map((r) => ({
    id: r.id,
    date: r.date,
    name: r.name,
    merchantName: r.merchantName ?? null,
    amount: parseFloat(String(r.amount)),
    category: r.category ?? null,
    accountName: r.accountName,
  }));
}
```

**File 2: `lib/agent/tools/trend-comparison.ts`** — TOOL-04

Compares total spending (or a specific category) between two date ranges. Returns both period totals and a delta, so the agent can answer "Am I spending more on dining this month vs last month?"

```typescript
/**
 * TOOL-04: Spending trend comparison across two time periods
 *
 * SEC-02: Drizzle .select() — SELECT only
 * SEC-03: Queries only transactions + accounts — no institutions
 */
import { db } from "@/lib/db";
import { transactions, accounts } from "@/lib/db/schema";
import { and, gte, lte, gt, sql, eq } from "drizzle-orm";

export interface TrendComparisonParams {
  period1From: string;   // ISO date "YYYY-MM-DD"
  period1To: string;     // ISO date "YYYY-MM-DD"
  period2From: string;   // ISO date "YYYY-MM-DD"
  period2To: string;     // ISO date "YYYY-MM-DD"
  category?: string;     // Optional: compare only within a category
}

export interface PeriodSummary {
  from: string;
  to: string;
  totalSpend: number;
  topCategories: Array<{ category: string; amount: number }>;
}

export interface TrendComparisonResult {
  period1: PeriodSummary;
  period2: PeriodSummary;
  delta: number;            // period2.totalSpend - period1.totalSpend (positive = increased spending)
  deltaPercent: number | null; // null if period1 was zero
  trend: "increased" | "decreased" | "unchanged";
}

async function getPeriodSummary(
  from: string,
  to: string,
  category?: string
): Promise<PeriodSummary> {
  const baseConditions = [
    gte(transactions.date, from),
    lte(transactions.date, to),
    gt(transactions.amount, "0"),
    eq(transactions.pending, false),
  ];

  if (category) baseConditions.push(eq(transactions.category, category));

  const rows = await db
    .select({
      category: transactions.category,
      total: sql<string>`sum(${transactions.amount})`,
    })
    .from(transactions)
    .innerJoin(accounts, eq(transactions.accountId, accounts.id))
    .where(and(...baseConditions))
    .groupBy(transactions.category)
    .orderBy(sql`sum(${transactions.amount}) desc`);

  const topCategories = rows.slice(0, 5).map((r) => ({
    category: r.category ?? "Uncategorized",
    amount: parseFloat(r.total ?? "0"),
  }));

  const totalSpend = rows.reduce((sum, r) => sum + parseFloat(r.total ?? "0"), 0);

  return { from, to, totalSpend, topCategories };
}

export async function compareTrends(
  params: TrendComparisonParams
): Promise<TrendComparisonResult> {
  const [period1, period2] = await Promise.all([
    getPeriodSummary(params.period1From, params.period1To, params.category),
    getPeriodSummary(params.period2From, params.period2To, params.category),
  ]);

  const delta = period2.totalSpend - period1.totalSpend;
  const deltaPercent =
    period1.totalSpend === 0
      ? null
      : Math.round((delta / period1.totalSpend) * 100 * 100) / 100;

  let trend: TrendComparisonResult["trend"];
  if (Math.abs(delta) < 0.01) {
    trend = "unchanged";
  } else if (delta > 0) {
    trend = "increased";
  } else {
    trend = "decreased";
  }

  return { period1, period2, delta, deltaPercent, trend };
}
```

**File 3: `lib/agent/tools/recurring-expenses.ts`** — TOOL-05

Returns active recurring items. Joins `accounts` for account name. Does NOT touch `institutions`.

```typescript
/**
 * TOOL-05: Recurring expenses listing
 *
 * SEC-02: Drizzle .select() — SELECT only
 * SEC-03: Joins recurringItems + accounts only — never institutions table
 */
import { db } from "@/lib/db";
import { recurringItems, accounts } from "@/lib/db/schema";
import { eq, asc } from "drizzle-orm";

export interface RecurringExpenseRow {
  id: string;
  name: string;
  merchantName: string | null;
  amount: number;
  frequency: string;
  lastDate: string | null;
  nextProjectedDate: string | null;
  accountName: string;
  isUserConfirmed: boolean;
}

export interface RecurringExpensesResult {
  items: RecurringExpenseRow[];
  totalMonthlyEstimate: number; // Normalized to monthly frequency
}

function toMonthlyAmount(amount: number, frequency: string): number {
  switch (frequency) {
    case "weekly":     return amount * 52 / 12;
    case "biweekly":   return amount * 26 / 12;
    case "monthly":    return amount;
    case "annually":   return amount / 12;
    default:           return amount;
  }
}

export async function getRecurringExpenses(): Promise<RecurringExpensesResult> {
  const rows = await db
    .select({
      id: recurringItems.id,
      name: recurringItems.name,
      merchantName: recurringItems.merchantName,
      amount: recurringItems.amount,
      frequency: recurringItems.frequency,
      lastDate: recurringItems.lastDate,
      nextProjectedDate: recurringItems.nextProjectedDate,
      isUserConfirmed: recurringItems.isUserConfirmed,
      accountName: accounts.name,
    })
    .from(recurringItems)
    .innerJoin(accounts, eq(recurringItems.accountId, accounts.id))
    .where(eq(recurringItems.isActive, true))
    .orderBy(asc(recurringItems.name));

  const items: RecurringExpenseRow[] = rows.map((r) => ({
    id: r.id,
    name: r.name,
    merchantName: r.merchantName ?? null,
    amount: parseFloat(String(r.amount)),
    frequency: r.frequency,
    lastDate: r.lastDate ?? null,
    nextProjectedDate: r.nextProjectedDate ?? null,
    accountName: r.accountName,
    isUserConfirmed: r.isUserConfirmed,
  }));

  const totalMonthlyEstimate = items.reduce(
    (sum, item) => sum + toMonthlyAmount(item.amount, item.frequency),
    0
  );

  return { items, totalMonthlyEstimate };
}
```
  </action>
  <verify>
1. TypeScript compiles all three files:
```bash
npx tsc --noEmit 2>&1 | grep -E "agent/tools/(transaction|trend|recurring)"
```
Expect no output (no errors).

2. Verify none of the three files import from `institutions`:
```bash
grep -n "institutions" lib/agent/tools/transaction-search.ts lib/agent/tools/trend-comparison.ts lib/agent/tools/recurring-expenses.ts
```
Expect: no output.

3. Verify transactionSearchSchema is exported (needed for Phase 2 AI SDK inputSchema):
```bash
grep "export const transactionSearchSchema" lib/agent/tools/transaction-search.ts
```

4. Smoke test all three tools against real database:
```bash
npx ts-node --project tsconfig.json -e "
const { searchTransactions } = require('./lib/agent/tools/transaction-search');
const { compareTrends } = require('./lib/agent/tools/trend-comparison');
const { getRecurringExpenses } = require('./lib/agent/tools/recurring-expenses');

async function test() {
  // TOOL-03
  const results = await searchTransactions({ query: 'a', limit: 3 });
  console.log('TOOL-03 count:', results.length, 'fields:', results[0] ? Object.keys(results[0]) : '(empty)');
  if (!Array.isArray(results)) throw new Error('TOOL-03: expected array');

  // TOOL-04
  const trends = await compareTrends({
    period1From: '2025-01-01', period1To: '2025-01-31',
    period2From: '2025-02-01', period2To: '2025-02-28',
  });
  console.log('TOOL-04 trend:', trends.trend, 'delta:', trends.delta);
  if (!trends.period1 || !trends.period2) throw new Error('TOOL-04: missing periods');

  // TOOL-05
  const recurring = await getRecurringExpenses();
  console.log('TOOL-05 items:', recurring.items.length, 'monthly estimate:', recurring.totalMonthlyEstimate);
  if (typeof recurring.totalMonthlyEstimate !== 'number') throw new Error('TOOL-05: bad type');

  // SEC-03: verify no sensitive fields in any result
  const allStr = JSON.stringify({ results, trends, recurring });
  if (allStr.includes('plaidAccessToken') || allStr.includes('syncCursor') || allStr.includes('errorCode')) {
    throw new Error('SECURITY FAIL: sensitive field in tool results');
  }
  console.log('PASS: TOOL-03, TOOL-04, TOOL-05 all returned safe data');
}
test().catch(e => { console.error('FAIL:', e); process.exit(1); });
"
```

5. Final check — all five tool files exist:
```bash
ls lib/agent/tools/
```
Expected: `account-balances.ts  recurring-expenses.ts  spending-summary.ts  transaction-search.ts  trend-comparison.ts`
  </verify>
  <done>
- `lib/agent/tools/transaction-search.ts` exports `transactionSearchSchema`, `TransactionSearchParams`, `searchTransactions`
- `lib/agent/tools/trend-comparison.ts` exports `TrendComparisonParams`, `TrendComparisonResult`, `compareTrends`
- `lib/agent/tools/recurring-expenses.ts` exports `RecurringExpensesResult`, `getRecurringExpenses`
- None of the three files import from `institutions` table
- TypeScript compiles all three without errors
- Smoke test returns structured data with no sensitive fields
- All five tool files present in `lib/agent/tools/`
  </done>
</task>

</tasks>

<verification>
Full Phase 1 verification — run after both tasks complete:

1. All five tool functions callable and return typed data:
```bash
npx ts-node --project tsconfig.json -e "
const tools = [
  require('./lib/agent/tools/spending-summary'),
  require('./lib/agent/tools/account-balances'),
  require('./lib/agent/tools/transaction-search'),
  require('./lib/agent/tools/trend-comparison'),
  require('./lib/agent/tools/recurring-expenses'),
];
console.log('All 5 tool modules loaded successfully');
console.log('Exports:', tools.map(t => Object.keys(t)));
"
```

2. TypeScript clean on all agent code:
```bash
npx tsc --noEmit 2>&1 | grep "agent"
```
Expect: no output.

3. No institutions table referenced in any tool file:
```bash
grep -r "institutions" lib/agent/
```
Expect: no output.

4. No NEXT_PUBLIC_ prefix on AI keys in env example:
```bash
grep "NEXT_PUBLIC_GEMINI" .env.example && echo "FAIL" || echo "PASS"
```

5. Views in database:
```bash
npx ts-node -e "
const {db} = require('./lib/db');
db.execute('SELECT table_name FROM information_schema.views WHERE table_schema=\'public\'').then(r => { console.log(r.rows); process.exit(0); });
"
```
</verification>

<success_criteria>
- Five files in `lib/agent/tools/` — one per tool function (TOOL-01 through TOOL-05)
- Each file: typed input interface, typed return interface, async function, no `any` types
- `account-balances.ts` queries `agentAccountsView` (never base institutions table)
- `spending-summary.ts`, `transaction-search.ts`, `trend-comparison.ts`, `recurring-expenses.ts` join only `accounts` (never `institutions`)
- `transactionSearchSchema` Zod schema exported from `transaction-search.ts` for Phase 2 reuse
- `npx tsc --noEmit` — zero errors across all five tool files
- Direct function calls return structured data with no plaidAccessToken/syncCursor/errorCode fields
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation-agent-tools/01-02-SUMMARY.md`
</output>
