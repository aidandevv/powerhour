---
phase: 01-security-foundation-agent-tools
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .husky/pre-commit
  - .gitignore
  - .env.example
  - lib/db/views.ts
  - lib/db/migrations/0000_agent_views.sql

autonomous: true

must_haves:
  truths:
    - "Committing a file containing a Plaid access token pattern (access-sandbox-|access-development-|access-production-) is blocked by the pre-commit hook with a clear error message"
    - "Committing a file containing a Gemini API key pattern (AIza[35 chars]) is blocked by the pre-commit hook"
    - "Committing a real .env file is blocked by the pre-commit hook"
    - "agent_accounts_view exists in the PostgreSQL database and SELECT returns rows with no plaid_access_token, sync_cursor, or error_code columns"
    - "agent_institutions_view exists in the PostgreSQL database and SELECT returns rows with only id, institution_name, status, last_synced_at columns"
    - "GEMINI_API_KEY is documented in .env.example without the NEXT_PUBLIC_ prefix and with a server-side-only note"
  artifacts:
    - path: ".husky/pre-commit"
      provides: "Pre-commit hook blocking secrets from being committed"
      contains: "AIza"
    - path: "lib/db/views.ts"
      provides: "Drizzle pgView definitions with .existing() for agent-safe column projection"
      exports: ["agentAccountsView", "agentInstitutionsView"]
    - path: "lib/db/migrations/0000_agent_views.sql"
      provides: "Custom SQL migration creating the two agent views in PostgreSQL"
      contains: "CREATE OR REPLACE VIEW agent_accounts_view"
    - path: ".env.example"
      provides: "Template documenting GEMINI_API_KEY (no NEXT_PUBLIC_ prefix)"
      contains: "GEMINI_API_KEY"
  key_links:
    - from: "lib/db/views.ts"
      to: "lib/db/migrations/0000_agent_views.sql"
      via: "pgView().existing() — TypeScript view definition matches SQL CREATE VIEW columns exactly"
      pattern: "agentAccountsView.*existing"
    - from: ".husky/pre-commit"
      to: "git staged files"
      via: "git diff --cached --name-only scanned before every commit"
      pattern: "git diff --cached"
---

<objective>
Establish all security controls for Phase 1: pre-commit secret scanning, agent-facing PostgreSQL database views (stripping sensitive columns), and environment variable documentation.

Purpose: These controls must exist before any agent code is written. They enforce the core constraint — the agent can never see Plaid tokens or encrypted blobs, and secrets can never leak into git history. The views are the structural foundation that Plan 01-02 tool functions build on.

Output: Husky pre-commit hook, two PostgreSQL views (created via custom SQL migration), Drizzle view definitions in lib/db/views.ts, and updated .env.example documenting GEMINI_API_KEY.
</objective>

<execution_context>
@/Users/aidan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aidan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-foundation-agent-tools/01-RESEARCH.md
@lib/db/schema.ts
@.env.example
@.gitignore
@middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Husky and write pre-commit secret scanning hook</name>
  <files>
    package.json
    .husky/pre-commit
  </files>
  <action>
Install husky v9 and lint-staged, then initialize and configure the pre-commit hook:

```bash
npm install --save-dev husky lint-staged
npx husky init
```

This creates `.husky/pre-commit` with a default `npm test` entry. Replace its contents entirely with the secret scanning script below.

Add to `package.json` scripts (if `prepare` not already present):
```json
"prepare": "husky"
```

Contents of `.husky/pre-commit`:
```sh
#!/bin/sh
# Scan staged files for secret patterns before commit
# Blocks: real .env files, Plaid access tokens, Google/Gemini API keys

STAGED=$(git diff --cached --name-only --diff-filter=ACM)

for file in $STAGED; do
  # Block .env files (not .env.example or .env.test)
  if echo "$file" | grep -qE '^\.env$|^\.env\.(local|production|development)$'; then
    echo "ERROR: Attempting to commit $file — environment file blocked."
    exit 1
  fi

  # Read staged file content
  CONTENT=$(git show ":$file" 2>/dev/null)
  if [ -z "$CONTENT" ]; then
    continue
  fi

  # Block Plaid access tokens (all environments)
  if echo "$CONTENT" | grep -qE 'access-(sandbox|development|production)-[0-9a-f]{8}-[0-9a-f]{4}'; then
    echo "ERROR: Possible Plaid access token in $file. Commit blocked."
    exit 1
  fi

  # Block Google/Gemini API keys (start with AIza, 39 chars total)
  if echo "$CONTENT" | grep -qE 'AIza[0-9A-Za-z_-]{35}'; then
    echo "ERROR: Possible Google/Gemini API key in $file. Commit blocked."
    exit 1
  fi

  # Block NEXT_PUBLIC_ prefixed AI keys (SEC-04 violation)
  if echo "$CONTENT" | grep -qE 'NEXT_PUBLIC_GEMINI_API_KEY'; then
    echo "ERROR: NEXT_PUBLIC_GEMINI_API_KEY found in $file — API key must be server-side only (SEC-04). Commit blocked."
    exit 1
  fi
done

exit 0
```

After writing the hook, make it executable:
```bash
chmod +x .husky/pre-commit
```

IMPORTANT: Do NOT add lint-staged config for this project — the hook is intentionally a standalone bash script, not lint-staged, because it needs to inspect file content via `git show` (not just run linters). lint-staged is installed but not configured.
  </action>
  <verify>
Run these checks to confirm the hook works:

1. Test that a staged fake .env file is blocked:
```bash
echo "TEST=value" > .env.test-hook && git add .env.test-hook 2>/dev/null || true
git stash -u 2>/dev/null || true
```
Actually test by creating a temp file with a Gemini key pattern and staging it, then running the hook directly:
```bash
echo 'GEMINI_API_KEY=[REDACTED-example-removed-per-security-audit]' > /tmp/test-secret.ts
# Verify the pattern matches
echo '[REDACTED-example-removed-per-security-audit]' | grep -qE 'AIza[0-9A-Za-z_-]{35}' && echo "PATTERN MATCHES" || echo "PATTERN MISS"
```

2. Verify hook is executable:
```bash
ls -la .husky/pre-commit
```

3. Verify `prepare` script in package.json:
```bash
node -e "const p=require('./package.json'); console.log(p.scripts.prepare)"
```
  </verify>
  <done>
- `.husky/pre-commit` exists and is executable (`-rwxr-xr-x`)
- `package.json` has `"prepare": "husky"` in scripts
- The Gemini key regex `AIza[0-9A-Za-z_-]{35}` matches a 39-char test key string
- The Plaid token regex matches `access-sandbox-...` pattern
- Running `npm install` would install the hook via `prepare` script
  </done>
</task>

<task type="auto">
  <name>Task 2: Create agent-facing DB views (Drizzle definitions + custom SQL migration)</name>
  <files>
    lib/db/views.ts
    lib/db/migrations/0000_agent_views.sql
  </files>
  <action>
Create two files:

**File 1: `lib/db/views.ts`**

This defines the Drizzle pgView types for TypeScript type inference. Use `.existing()` because the views are created by the SQL migration, not by drizzle-kit. The column definitions MUST exactly match the SQL CREATE VIEW SELECT list below.

```typescript
/**
 * Agent-facing database views.
 *
 * These views expose only safe, non-sensitive columns to the AI agent tool
 * functions. The base `institutions` table contains `plaid_access_token`
 * (AES-256-GCM encrypted) and `sync_cursor` — these MUST NOT appear in any
 * agent query result. These views enforce that exclusion at the database layer.
 *
 * SEC-02: Read-only by design (views cannot INSERT/UPDATE/DELETE)
 * SEC-03: plaid_access_token, sync_cursor, error_code excluded from all views
 *
 * IMPORTANT: Views are created via custom SQL migration (0000_agent_views.sql).
 * drizzle-kit cannot create views via db:push or auto-migration.
 * These definitions use .existing() for type inference only.
 */
import { pgView } from "drizzle-orm/pg-core";
import { text, uuid, numeric, boolean, timestamp } from "drizzle-orm/pg-core";

/**
 * Safe accounts view.
 * Joins accounts + institutions but EXCLUDES:
 * - institutions.plaid_access_token
 * - institutions.sync_cursor
 * - institutions.error_code
 * - institutions.plaid_item_id
 * - institutions.plaid_institution_id (internal Plaid ID)
 *
 * Agent tool functions MUST use this view (never base accounts/institutions tables).
 */
export const agentAccountsView = pgView("agent_accounts_view", {
  id: uuid("id"),
  name: text("name"),
  officialName: text("official_name"),
  type: text("type"),
  subtype: text("subtype"),
  currencyCode: text("currency_code"),
  currentBalance: numeric("current_balance", { precision: 14, scale: 2 }),
  availableBalance: numeric("available_balance", { precision: 14, scale: 2 }),
  creditLimit: numeric("credit_limit", { precision: 14, scale: 2 }),
  isActive: boolean("is_active"),
  institutionId: uuid("institution_id"),
  institutionName: text("institution_name"),
  institutionStatus: text("institution_status"),
  lastSyncedAt: timestamp("last_synced_at", { withTimezone: true }),
}).existing();

/**
 * Safe institutions view.
 * Exposes institution name and sync status only.
 * Never exposes plaid_access_token, sync_cursor, or error_code.
 */
export const agentInstitutionsView = pgView("agent_institutions_view", {
  id: uuid("id"),
  institutionName: text("institution_name"),
  status: text("status"),
  lastSyncedAt: timestamp("last_synced_at", { withTimezone: true }),
}).existing();
```

**File 2: `lib/db/migrations/0000_agent_views.sql`**

This is the custom SQL migration that actually creates the views in PostgreSQL. Run it via `npm run db:migrate`.

```sql
-- Agent-facing database views
-- SEC-02: Views are inherently read-only (no INSERT/UPDATE/DELETE possible)
-- SEC-03: Excludes plaid_access_token, sync_cursor, error_code from all results
--
-- Apply with: npm run db:migrate

CREATE OR REPLACE VIEW agent_accounts_view AS
SELECT
  a.id,
  a.name,
  a.official_name,
  a.type,
  a.subtype,
  a.currency_code,
  a.current_balance,
  a.available_balance,
  a.credit_limit,
  a.is_active,
  a.institution_id,
  i.institution_name,
  i.status AS institution_status,
  i.last_synced_at
FROM accounts a
INNER JOIN institutions i ON a.institution_id = i.id
WHERE a.is_active = true;

CREATE OR REPLACE VIEW agent_institutions_view AS
SELECT
  id,
  institution_name,
  status,
  last_synced_at
FROM institutions;
```

After creating both files, run the migration to create the views in the database:
```bash
npm run db:migrate
```

If `db:migrate` fails because there is no migration journal (first migration ever), run:
```bash
npx drizzle-kit generate --custom --name=agent_views
```
This generates a blank migration file. Then replace its contents with the SQL above, and run `npm run db:migrate`.

NOTE: The drizzle.config.ts already points migrations to `./lib/db/migrations` — confirmed. No config changes needed.
  </action>
  <verify>
1. Verify files exist:
```bash
ls lib/db/views.ts lib/db/migrations/0000_agent_views.sql
```

2. Verify TypeScript compiles (no type errors in views.ts):
```bash
npx tsc --noEmit 2>&1 | grep -i "views"
```

3. Verify views exist in the database:
```bash
npx ts-node -e "
const { db } = require('./lib/db');
async function check() {
  const rows = await db.execute('SELECT table_name FROM information_schema.views WHERE table_schema = \'public\'');
  console.log(rows.rows);
}
check().catch(e => console.error(e)).finally(() => process.exit(0));
"
```
Expected output: rows containing `agent_accounts_view` and `agent_institutions_view`

4. Verify no sensitive columns in the views:
```bash
npx ts-node -e "
const { db } = require('./lib/db');
async function check() {
  const cols = await db.execute('SELECT column_name FROM information_schema.columns WHERE table_name = \'agent_accounts_view\' AND table_schema = \'public\'');
  const names = cols.rows.map(r => r.column_name);
  console.log('Columns:', names);
  const sensitive = ['plaid_access_token','sync_cursor','error_code','plaid_item_id'];
  const found = sensitive.filter(s => names.includes(s));
  if (found.length > 0) { console.error('FAIL: sensitive columns found:', found); process.exit(1); }
  console.log('PASS: no sensitive columns in view');
}
check().catch(e => console.error(e)).finally(() => process.exit(0));
"
```
  </verify>
  <done>
- `lib/db/views.ts` exports `agentAccountsView` and `agentInstitutionsView` using `pgView().existing()`
- `lib/db/migrations/0000_agent_views.sql` contains `CREATE OR REPLACE VIEW agent_accounts_view` and `CREATE OR REPLACE VIEW agent_institutions_view`
- Both views exist in the PostgreSQL database (`information_schema.views` confirms)
- Column check confirms NO `plaid_access_token`, `sync_cursor`, `error_code` in `agent_accounts_view`
- `npx tsc --noEmit` reports no errors in `lib/db/views.ts`
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit .gitignore and update .env.example with GEMINI_API_KEY</name>
  <files>
    .gitignore
    .env.example
  </files>
  <action>
**Step 1: Audit .gitignore**

Read the current `.gitignore`. Verify it already contains:
- `.env` (blocks the real env file)
- `.env*.local`
- `.env.local`

If `.env.production` and `.env.development` are not explicitly listed, add them. The current `.gitignore` has `.env` and `.env*.local` — this is sufficient for Next.js conventions. Confirm these patterns exist and add any gaps.

Also confirm `node_modules/` and `.next/` are present. If the file already covers all these, no change is needed — just document the confirmation.

**Step 2: Update .env.example**

Add the AI agent section to `.env.example`. Append the following block after the existing `NEXT_PUBLIC_APP_URL` line:

```
# --- AI Agent (server-side only) ---
# Google Gemini API key for the AI financial agent.
# SECURITY (SEC-04): This key MUST NOT have the NEXT_PUBLIC_ prefix.
# Any NEXT_PUBLIC_GEMINI_API_KEY would be baked into the client JavaScript bundle
# and exposed to every user's browser. Use GEMINI_API_KEY only.
# Get from: https://aistudio.google.com/app/apikey
GEMINI_API_KEY=                   # Google AI Studio API key (starts with AIza...)
```

The full updated `.env.example` should be the existing content plus this new section. Read the current file first, then write the full updated content.
  </action>
  <verify>
1. Confirm .gitignore blocks real env files:
```bash
git check-ignore -v .env 2>/dev/null && echo "BLOCKED" || echo "NOT BLOCKED"
```

2. Confirm .env.example has GEMINI_API_KEY without NEXT_PUBLIC_ prefix:
```bash
grep "GEMINI_API_KEY" .env.example
grep "NEXT_PUBLIC_GEMINI" .env.example && echo "FAIL: found NEXT_PUBLIC_ prefix" || echo "PASS: no NEXT_PUBLIC_ prefix"
```

3. Verify .env.example does NOT contain actual secrets (just placeholder empty values):
```bash
grep -E 'AIza[0-9A-Za-z_-]{35}' .env.example && echo "FAIL: real key found" || echo "PASS: no real key"
```
  </verify>
  <done>
- `.gitignore` blocks `.env` (confirmed via `git check-ignore`)
- `.env.example` contains `GEMINI_API_KEY=` (no NEXT_PUBLIC_ prefix)
- `.env.example` contains a comment stating this key MUST NOT have NEXT_PUBLIC_ prefix
- No actual API key values present in `.env.example`
  </done>
</task>

</tasks>

<verification>
After all three tasks complete, run the full security verification:

1. Pre-commit hook is executable and blocks Gemini key patterns
2. Views exist in database with correct column exclusions
3. TypeScript compiles without errors (`npx tsc --noEmit`)
4. `.env.example` documents `GEMINI_API_KEY` correctly (server-side only)
5. `.gitignore` confirmed blocking `.env`
</verification>

<success_criteria>
- Husky pre-commit hook installed and executable, blocks .env files and secret patterns
- `agent_accounts_view` and `agent_institutions_view` exist in PostgreSQL
- `lib/db/views.ts` exports both view definitions with `.existing()`, no TypeScript errors
- `lib/db/migrations/0000_agent_views.sql` contains the CREATE VIEW DDL
- `.env.example` documents `GEMINI_API_KEY` (no NEXT_PUBLIC_ prefix) with server-side warning
- `npm install` would install the husky hook automatically via `prepare` script
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-foundation-agent-tools/01-01-SUMMARY.md`
</output>
